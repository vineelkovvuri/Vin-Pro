<!-- manual page source format generated by RosettaMan, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->
<HTML>
<HEADER>
<TITLE>Gnu lexical analyser</TITLE>
</HEADER>
<BODY>
<A HREF="#toc">Table of Contents</A><P>

<A NAME="sect0" HREF="#toc0"><H2>NAME</H2></A>
flex - fast lexical analyzer generator<P>

<A NAME="sect1" HREF="#toc1"><H2><B>SYNOPSIS</B></H2></A>
<B>flex</B> <B>[-bcdfinpstvFILT8</B> <B>-C[efmF]</B> <B>-Sskeleton]</B> [<I>filename</I> ...]<P>

<A NAME="sect2" HREF="#toc2"><H2><B>DESCRIPTION</B></H2></A>
<I>flex</I> is a tool for generating <I>scanners</I>: programs which recognized lexical patterns in text. <I>flex</I> reads the given input files, or its standard input if no file names are given, for a description of a scanner to generate. The description is in the form of pairs of regular expressions and C code, called <I>rules</I>. <I>flex</I> generates as output a C source file, <B>lex.yy.c,</B> which defines a routine <B>yylex().</B> This file is compiled and linked with the <B>-lfl</B> library to produce an executable. When the executable is run, it analyzes its input for occurrences of the regular expressions. Whenever it finds one, it executes the corresponding C code.<P>

<A NAME="sect3" HREF="#toc3"><H2><B>SOME</B> <B>SIMPLE</B> <B>EXAMPLES</B></H2></A>
First some simple examples to get the flavor of how one uses <I>flex</I>. The following <I>flex</I> input specifies a scanner which whenever it encounters the string &quot;username&quot; will replace it with the user's login name:<P>
%%<BR>
 <dl>
<dt>username <dd>   printf( &quot;%s", getlogin() );<P>
</dd>
</dl>
By default, any text not matched by a <I>flex</I> scanner is copied to the output, so the net effect of this scanner is to copy its input file to its output with each occurrence of &quot;username" expanded. In this input, there is just one rule. &quot;username&quot; is the <I>pattern</I> and the &quot;printf&quot; is the <I>action</I>. The &quot;%%&quot; marks the beginning of the rules.<P>
Here's another simple example:<P>
int num_lines = 0, num_chars = 0;<P>
%%<BR>
 <dl>
<dt>\n <dd>   ++num_lines; ++num_chars; </dd>
</dl>
<dl>
<dt>. <dd>    ++num_chars;<P>
</dd>
</dl>
%%<BR>
 main()<BR>
 {<BR>
 yylex();<BR>
 printf( &quot;# of lines = %d, # of chars = %d\n", num_lines, num_chars );<BR>
 }<P>
This scanner counts the number of characters and the number of lines in its input (it produces no output other than the final report on the counts). The first line declares two globals, &quot;num_lines&quot; and &quot;num_chars", which are accessible both inside <B>yylex()</B> and in the <B>main()</B> routine declared after the second &quot;%%". There are two rules, one which matches a newline ("\n") and increments both the line count and the character count, and one which matches any character other than a newline (indicated by the &quot;.&quot; regular expression).<P>
A somewhat more complicated example:<P>
/* scanner for a toy Pascal-like language */<P>
%{<BR>
 /* need this for the call to atof() below */ #include &lt;math.h&gt;<BR>
 %}<P>
<dl>
<dt>DIGIT <dd>   [0-9] </dd>
</dl>
<dl>
<dt>ID <dd>      [a-z][a-z0-9]*<P>
</dd>
</dl>
%%<P>
<dl>
<dt>{DIGIT}+ <dd>   { printf( &quot;An integer: %s (%d)\n", yytext, atoi( yytext ) ); }<P>
</dd>
</dl>
<dl>
<dt>{DIGIT}+"."{DIGIT}* <dd>       { printf( &quot;A float: %s (%g)\n", yytext, atof( yytext ) ); }<P>
</dd>
</dl>
<dl>
<dt>if|then|begin|end|procedure|function <dd>       { printf( &quot;A keyword: %s\n", yytext ); }<P>
</dd>
</dl>
<dl>
<dt>{ID} <dd>       printf( &quot;An identifier: %s\n", yytext );<P>
</dd>
</dl>
<dl>
<dt>&quot;+"|"-"|"*"|"/&quot; <dd>printf( &quot;An operator: %s\n", yytext );<P>
</dd>
</dl>
<dl>
<dt>&quot;{"[^}\n]*"}&quot; <dd>    /* eat up one-line comments */<P>
</dd>
</dl>
<dl>
<dt>[ \t\n]+ <dd>         /* eat up whitespace */<P>
</dd>
</dl>
<dl>
<dt>. <dd>          printf( &quot;Unrecognized character: %s\n", yytext );<P>
</dd>
</dl>
%%<P>
main( argc, argv )<BR>
 int argc;<BR>
 char **argv;<P>
{<BR>
 ++argv, --argc; /* skip over program name */ if ( argc &gt; 0 )<BR>
 yyin = fopen( argv[0], &quot;r&quot; ); else<BR>
 yyin = stdin;<P>
yylex();<BR>
 }<P>
This is the beginnings of a simple scanner for a language like Pascal. It identifies different types of <I>tokens</I> and reports on what it has seen.<P>
The details of this example will be explained in the following sections.<P>

<A NAME="sect4" HREF="#toc4"><H2><B>FORMAT</B> <B>OF</B> <B>THE</B> <B>INPUT</B> <B>FILE</B></H2></A>
The <I>flex</I> input file consists of three sections, separated by a line with just <B>%%</B> in it:<P>
definitions<BR>
 %%<BR>
 rules<BR>
 %%<BR>
 user code<P>
The <I>definitions</I> section contains declarations of simple <I>name</I> definitions to simplify the scanner specification, and declarations of <I>start</I> <I>conditions</I>, which are explained in a later section.<P>
Name definitions have the form:<P>
name definition<P>
The &quot;name&quot; is a word beginning with a letter or an underscore ('_') followed by zero or more letters, digits, `_', or `-' (dash). The definition is taken to begin at the first non-white-space character following the name and continuing to the end of the line. The definition can subsequently be referred to using &quot;{name}", which will expand to &quot;(definition)". For example,<P>
<dl>
<dt>DIGIT <dd>   [0-9] </dd>
</dl>
<dl>
<dt>ID <dd>      [a-z][a-z0-9]*<P>
</dd>
</dl>
defines &quot;DIGIT&quot; to be a regular expression which matches a single digit, and &quot;ID&quot; to be a regular expression which matches a letter followed by zero-or-more letters-or-digits. A subsequent reference to<P>
{DIGIT}+"."{DIGIT}*<P>
is identical to<P>
([0-9])+"."([0-9])*<P>
and matches one-or-more digits followed by a `.' followed by zero-or-more digits.<P>
The <I>rules</I> section of the <I>flex</I> input contains a series of rules of the form:<P>
pattern action<P>
where the pattern must be unindented and the action must begin on the same line.<P>
See below for a further description of patterns and actions.<P>
Finally, the user code section is simply copied to <B>lex.yy.c</B> verbatim. It is used for companion routines which call or are called by the scanner. The presence of this section is optional; if it is missing, the second <B>%%</B> in the input file may be skipped, too.<P>
In the definitions and rules sections, any <I>indented</I> text or text enclosed in <B>%{</B> and <B>%}</B> is copied verbatim to the output (with the %{}'s removed). The %{}'s must appear unindented on lines by themselves.<P>
In the rules section, any indented or %{} text appearing before the first rule may be used to declare variables which are local to the scanning routine and (after the declarations) code which is to be executed whenever the scanning routine is entered. Other indented or %{} text in the rule section is still copied to the output, but its meaning is not well-defined and it may well cause compile-time errors (this feature is present for <I>POSIX</I> compliance; see below for other such features).<P>
In the definitions section, an unindented comment (i.e., a line beginning with &quot;/*") is also copied verbatim to the output up to the next &quot;*/". Also, any line in the definitions section beginning with `#' is ignored, though this style of comment is deprecated and may go away in the future.<P>

<A NAME="sect5" HREF="#toc5"><H2><B>PATTERNS</B></H2></A>
The patterns in the input are written using an extended set of regular expressions. These are:<P>
<dl>
<dt>x <dd>         match the character `x'<P>
</dd>
</dl>
<dl>
<dt>. <dd>         any character except newline </dd>
</dl>
<dl>
<dt>[xyz] <dd>     a &quot;character class"; in this case, the pattern matches either an `x', a `y', or a `z' </dd>
</dl>
<dl>
<dt>[abj-oZ] <dd>a &quot;character class&quot; with a range in it; matches an `a', a `b', any letter from `j' through `o', or a `Z' </dd>
</dl>
<dl>
<dt>[^A-Z] <dd>    a &quot;negated character class", i.e., any character but those in the class. In this case, any character EXCEPT an uppercase letter. </dd>
</dl>
<dl>
<dt>[^A-Z\n] <dd>any character EXCEPT an uppercase letter or a newline </dd>
</dl>
<dl>
<dt>r* <dd>        zero or more r's, where r is any regular expression </dd>
</dl>
<dl>
<dt>r+ <dd>        one or more r's </dd>
</dl>
<dl>
<dt>r? <dd>        zero or one r's (that is, &quot;an optional r") </dd>
</dl>
<dl>
<dt>r{2,5} <dd>    anywhere from two to five r's </dd>
</dl>
<dl>
<dt>r{2,} <dd>     two or more r's </dd>
</dl>
<dl>
<dt>r{4} <dd>      exactly 4 r's </dd>
</dl>
<dl>
<dt>{name} <dd>    the expansion of the &quot;name&quot; definition (see above) &quot;[xyz]\"foo" the literal string: [xyz]"foo </dd>
</dl>
<dl>
<dt>\X <dd>        if X is an `a', `b', `f', `n', `r', `t', or `v', then the ANSI-C interpretation of \x. Otherwise, a literal `X' (used to escape operators such as `*') </dd>
</dl>
<dl>
<dt>\123 <dd>      the character with octal value 123 </dd>
</dl>
<dl>
<dt>\x2a <dd>      the character with hexadecimal value 2a </dd>
</dl>
<dl>
<dt>(r) <dd>       match an r; parentheses are used to override precedence (see below)<P>
</dd>
</dl>
<dl>
<dt>rs <dd>        the regular expression r followed by the regular expression s; called &quot;concatenation"<P>
</dd>
</dl>
<dl>
<dt>r|s <dd>       either an r or an s<P>
</dd>
</dl>
<dl>
<dt>r/s <dd>       an r but only if it is followed by an s. The s is not part of the matched text. This type of pattern is called as &quot;trailing context". </dd>
</dl>
<dl>
<dt>^r <dd>        an r, but only at the beginning of a line </dd>
</dl>
<dl>
<dt>r$ <dd>        an r, but only at the end of a line. Equivalent to &quot;r/\n".<P>
</dd>
</dl>
<dl>
<dt>&lt;s&gt;r <dd>      an r, but only in start condition s (see below for discussion of start conditions) &lt;s1,s2,s3&gt;r same, but in any of start conditions s1, s2, or s3<P>
</dd>
</dl>
<dl>
<dt>&lt;&lt;EOF&gt;&gt; <dd>   an end-of-file &lt;s1,s2&gt;&lt;&lt;EOF&gt;&gt; an end-of-file when in start condition s1 or s2<P>
</dd>
</dl>
The regular expressions listed above are grouped according to precedence, from highest precedence at the top to lowest at the bottom. Those grouped together have equal precedence. For example,<P>
foo|bar*<P>
is the same as<P>
(foo)|(ba(r*))<P>
since the `*' operator has higher precedence than concatenation, and concatenation higher than alternation ('|'). This pattern therefore matches <I>either</I> the string &quot;foo&quot; <I>or</I> the string &quot;ba&quot; followed by zero-or-more r's. To match &quot;foo&quot; or zero-or-more &quot;bar"'s, use:<P>
foo|(bar)*<P>
and to match zero-or-more &quot;foo"'s-or-"bar"'s:<P>
(foo|bar)*<P>
Some notes on patterns:<P>
<dl>
<dt>- <dd>   A negated character class such as the example &quot;[^A-Z]" above <I>will</I> <I>match</I> <I>a</I> <I>newline</I> unless &quot;\n&quot; (or an equivalent escape sequence) is one of the characters explicitly present in the negated character class (e.g., &quot;[^A-Z\n]"). This is unlike how many other regular expression tools treat negated character classes, but unfortunately the inconsistency is historically entrenched. Matching newlines means that a pattern like [^"]* can match an entire input (overflowing the scanner's input buffer) unless there's another quote in the input.<P>
</dd>
</dl>
<dl>
<dt>- <dd>   A rule can have at most one instance of trailing context (the `/' operator or the `$' operator). The start condition, `^', and &quot;&lt;&lt;EOF&gt;&gt;&quot; patterns can only occur at the beginning of a pattern, and, as well as with `/' and `$', cannot be grouped inside parentheses. A `^' which does not occur at the beginning of a rule or a `$' which does not occur at the end of a rule loses its special properties and is treated as a normal character.<P>
</dd>
</dl>
The following are illegal:<P>
foo/bar$<BR>
 &lt;sc1&gt;foo&lt;sc2&gt;bar<P>
Note that the first of these, can be written &quot;foo/bar\n".<P>
The following will result in `$' or `^' being treated as a normal character:<P>
foo|(bar$)<BR>
 foo|^bar<P>
If what's wanted is a &quot;foo&quot; or a bar-followed-by-anewline, the following could be used (the special `|' action is explained below):<P>
<dl>
<dt>foo <dd>     | </dd>
</dl>
<dl>
<dt>bar$ <dd>    /* action goes here */<P>
</dd>
</dl>
A similar trick will work for matching a foo or a barat-the-beginning-of-a-line.<P>

<A NAME="sect6" HREF="#toc6"><H2><B>HOW</B> <B>THE</B> <B>INPUT</B> <B>IS</B> <B>MATCHED</B></H2></A>
When the generated scanner is run, it analyzes its input looking for strings which match any of its patterns. If it finds more than one match, it takes the one matching the most text (for trailing context rules, this includes the length of the trailing part, even though it will then be returned to the input). If it finds two or more matches of the same length, the rule listed first in the <I>flex</I> input file is chosen.<P>
Once the match is determined, the text corresponding to the match (called the <I>token</I>) is made available in the global character pointer <B>yytext,</B> and its length in the global integer <B>yyleng.</B> The <I>action</I> corresponding to the matched pattern is then executed (a more detailed description of actions follows), and then the remaining input is scanned for another match.<P>
If no match is found, then the <I>default</I> <I>rule</I> is executed: the next character in the input is considered matched and copied to the standard output. Thus, the simplest legal <I>flex</I> input is:<P>
%%<P>
which generates a scanner that simply copies its input (one character at a time) to its output.<P>

<A NAME="sect7" HREF="#toc7"><H2><B>ACTIONS</B></H2></A>
Each pattern in a rule has a corresponding action, which can be any arbitrary C statement. The pattern ends at the first non-escaped whitespace character; the remainder of the line is its action. If the action is empty, then when the pattern is matched the input token is simply discarded. For example, here is the specification for a program which deletes all occurrences of &quot;zap me&quot; from its input:<P>
%%<BR>
 &quot;zap me"<P>
(It will copy all other characters in the input to the output since they will be matched by the default rule.)<P>
Here is a program which compresses multiple blanks and tabs down to a single blank, and throws away whitespace found at the end of a line:<P>
%%<BR>
 <dl>
<dt>[ \t]+ <dd>       putchar( ` ` ); </dd>
</dl>
<dl>
<dt>[ \t]+$ <dd>      /* ignore this token */<P>
</dd>
</dl>
If the action contains a `{', then the action spans till the balancing `}' is found, and the action may cross multiple lines. <I>flex</I> knows about C strings and comments and won't be fooled by braces found within them, but also allows actions to begin with <B>%{</B> and will consider the action to be all the text up to the next <B>%}</B> (regardless of ordinary braces inside the action).<P>
An action consisting solely of a vertical bar ('|') means &quot;same as the action for the next rule.&quot; See below for an illustration.<P>
Actions can include arbitrary C code, including <B>return</B> statements to return a value to whatever routine called <B>yylex().</B> Each time <B>yylex()</B> is called it continues processing tokens from where it last left off until it either reaches the end of the file or executes a return. Once it reaches an end-of-file, however, then any subsequent call to <B>yylex()</B> will simply immediately return, unless <B>yyrestart()</B> is first called (see below).<P>
Actions are not allowed to modify yytext or yyleng.<P>
There are a number of special directives which can be included within an action:<P>
<dl>
<dt>-    <dd><B>ECHO</B> copies yytext to the scanner's output.<P>
</dd>
</dl>
<dl>
<dt>-    <B>BEGIN</B> followed by the name of a start condition places<dd> the scanner in the corresponding start condition (see below).<P>
</dd>
</dl>
<dl>
<dt>-    <B>REJECT</B> directs the scanner to proceed on to the &quot;second<dd> best&quot; rule which matched the input (or a prefix of the input). The rule is chosen as described above in &quot;How the Input is Matched", and <B>yytext</B> and <B>yyleng</B> set up appropriately. It may either be one which matched as much text as the originally chosen rule but came later in the <I>flex</I> input file, or one which matched less text. For example, the following will both count the words in the input and call the routine special() whenever &quot;frob&quot; is seen:<P>
</dd>
</dl>
int word_count = 0;<BR>
 %%<P>
<dl>
<dt>frob <dd>       special(); REJECT; </dd>
</dl>
<dl>
<dt>[^ \t\n]+ <dd>++word_count;<P>
</dd>
</dl>
Without the <B>REJECT,</B> any &quot;frob"'s in the input would not be counted as words, since the scanner normally executes only one action per token. Multiple <B>REJECT's</B> are allowed, each one finding the next best choice to the currently active rule. For example, when the following scanner scans the token &quot;abcd", it will write &quot;abcdabcaba" to the output:<P>
%%<BR>
 <dl>
<dt>a <dd>       | </dd>
</dl>
<dl>
<dt>ab <dd>      | </dd>
</dl>
<dl>
<dt>abc <dd>     | </dd>
</dl>
<dl>
<dt>abcd <dd>    ECHO; REJECT; </dd>
</dl>
<dl>
<dt>.|\n <dd>    /* eat up any unmatched character */<P>
</dd>
</dl>
(The first three rules share the fourth's action since they use the special `|' action.) <B>REJECT</B> is a particularly expensive feature in terms scanner performance; if it is used in <I>any</I> of the scanner's actions it will slow down <I>all</I> of the scanner's matching. Furthermore, <B>REJECT</B> cannot be used with the -<I>f</I> or -<I>F</I> options (see below).<P>
Note also that unlike the other special actions, <B>REJECT</B> is a <I>branch</I>; code immediately following it in the action will <I>not</I> be executed.<P>
<dl>
<dt>-    <B>yymore()</B> tells the scanner that the next time it<dd> matches a rule, the corresponding token should be <I>appended</I> onto the current value of <B>yytext</B> rather than replacing it. For example, given the input &quot;mega kludge&quot; the following will write &quot;mega-mega-kludge&quot; to the output:<P>
</dd>
</dl>
%%<BR>
 <dl>
<dt>mega- <dd>   ECHO; yymore(); kludge ECHO;<P>
</dd>
</dl>
First &quot;mega-&quot; is matched and echoed to the output. Then &quot;kludge&quot; is matched, but the previous &quot;mega-&quot; is still hanging around at the beginning of <B>yytext</B> so the <B>ECHO</B> for the &quot;kludge&quot; rule will actually write &quot;megakludge". The presence of <B>yymore()</B> in the scanner's action entails a minor performance penalty in the scanner's matching speed.<P>
<dl>
<dt>-    <A HREF="http://www.stna7.stna.dgac.fr/cgi-bin/man2html?yyless?n">yyless(n)</A> returns all but the first n characters of the<dd> current token back to the input stream, where they will be rescanned when the scanner looks for the next match. <B>yytext</B> and <B>yyleng</B> are adjusted appropriately (e.g., <B>yyleng</B> will now be equal to <I>n</I> ). For example, on the input &quot;foobar&quot; the following will write out &quot;foobarbar":<P>
</dd>
</dl>
%%<BR>
 <dl>
<dt>foobar <dd>   ECHO; <A HREF="http://www.stna7.stna.dgac.fr/cgi-bin/man2html?yyless?3">yyless(3)</A>; </dd>
</dl>
<dl>
<dt>[a-z]+ <dd>   ECHO;<P>
</dd>
</dl>
An argument of 0 to <B>yyless</B> will cause the entire current input string to be scanned again. Unless you've changed how the scanner will subsequently process its input (using <B>BEGIN,</B> for example), this will result in an endless loop.<P>
<dl>
<dt>-    <B>unput(c)</B> puts the character <I>c</I> back onto the input<dd> stream. It will be the next character scanned. The following action will take the current token and cause it to be rescanned enclosed in parentheses.<P>
</dd>
</dl>
{<BR>
 int i;<BR>
 unput( `)' );<BR>
 for ( i = yyleng - 1; i &gt;= 0; --i ) unput( yytext[i] );<BR>
 unput( `(' );<BR>
 }<P>
Note that since each <B>unput()</B> puts the given character back at the <I>beginning</I> of the input stream, pushing back strings must be done back-to-front.<P>
<dl>
<dt>-    <B>input()</B> reads the next character from the input stream.<dd> For example, the following is one way to eat up C comments:<P>
</dd>
</dl>
%%<BR>
 <dl>
<dt>&quot;/*&quot; <dd>       { register int c;<P>
</dd>
</dl>
for ( ; ; )<BR>
 {<BR>
 while ( (c = input()) != `*' &amp;&amp; c != EOF ) <dl>
<dt>; <dd>   /* eat up text of comment */<P>
</dd>
</dl>
if ( c == `*' ) {<BR>
 while ( (c = input()) == `*' ) ;<BR>
 if ( c == `/' ) <dl>
<dt>break; <dd>   /* found the end */ }<P>
</dd>
</dl>
if ( c == EOF ) {<BR>
 error( &quot;EOF in comment&quot; ); break;<BR>
 }<BR>
 }<BR>
 }<P>
(Note that if the scanner is compiled using <B>C++,</B> then <B>input()</B> is instead referred to as <B>yyinput(),</B> in order to avoid a name clash with the <B>C++</B> stream by the name of <I>input</I>.)<P>
<dl>
<dt>-    <B>yyterminate()</B> can be used in lieu of a return statement<dd> in an action. It terminates the scanner and returns a 0 to the scanner's caller, indicating &quot;all done". Subsequent calls to the scanner will immediately return unless preceded by a call to <B>yyrestart()</B> (see below). By default, <B>yyterminate()</B> is also called when an endof-file is encountered. It is a macro and may be redefined.<P>
</dd>
</dl>

<A NAME="sect8" HREF="#toc8"><H2><B>THE</B> <B>GENERATED</B> <B>SCANNER</B></H2></A>
The output of <I>flex</I> is the file <B>lex.yy.c,</B> which contains the scanning routine <B>yylex(),</B> a number of tables used by it for matching tokens, and a number of auxiliary routines and macros. By default, <B>yylex()</B> is declared as follows:<P>
int yylex()<BR>
 {<BR>
 ... various definitions and the actions in here ... }<P>
(If your environment supports function prototypes, then it will be &quot;int yylex( void )".) This definition may be changed by redefining the &quot;YY_DECL&quot; macro. For example, you could use:<P>
#undef YY_DECL<BR>
 #define YY_DECL float lexscan( a, b ) float a, b;<P>
to give the scanning routine the name <I>lexscan</I>, returning a float, and taking two floats as arguments. Note that if you give arguments to the scanning routine using a K&amp;Rstyle/non-prototyped function declaration, you must terminate the definition with a semi-colon (;).<P>
Whenever <B>yylex()</B> is called, it scans tokens from the global input file <I>yyin</I> (which defaults to stdin). It continues until it either reaches an end-of-file (at which point it returns the value 0) or one of its actions executes a <I>return</I> statement. In the former case, when called again the scanner will immediately return unless <B>yyrestart()</B> is called to point <I>yyin</I> at the new input file. ( <B>yyrestart()</B> takes one argument, a <B>FILE</B> <B>*</B> pointer.) In the latter case (i.e., when an action executes a return), the scanner may then be called again and it will resume scanning where it left off.<P>
By default (and for purposes of efficiency), the scanner uses block-reads rather than simple <I>getc</I>() calls to read characters from <I>yyin</I>. The nature of how it gets its input can be controlled by redefining the <B>YY_INPUT</B> macro. YY_INPUT's           calling           sequence           is &quot;YY_INPUT(buf,result,max_size)". Its action is to place up to <I>max</I>_<I>size</I> characters in the character array <I>buf</I> and return in the integer variable <I>result</I> either the number of characters read or the constant YY_NULL (0 on Unix systems) to indicate EOF. The default YY_INPUT reads from the global file-pointer &quot;yyin".<P>
A sample redefinition of YY_INPUT (in the definitions section of the input file):<P>
%{<BR>
 #undef YY_INPUT<BR>
 #define YY_INPUT(buf,result,max_size) \ { \<BR>
 int c = getchar(); \<BR>
 result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \ }<BR>
 %}<P>
This definition will change the input processing to occur one character at a time.<P>
You also can add in things like keeping track of the input line number this way; but don't expect your scanner to go very fast.<P>
When the scanner receives an end-of-file indication from YY_INPUT, it then checks the <B>yywrap()</B> function. If <B>yywrap()</B> returns false (zero), then it is assumed that the function has gone ahead and set up <I>yyin</I> to point to another input file, and scanning continues. If it returns true (nonzero), then the scanner terminates, returning 0 to its caller.<P>
The default <B>yywrap()</B> always returns 1. Presently, to redefine it you must first &quot;#undef yywrap", as it is currently implemented as a macro. As indicated by the hedging in the previous sentence, it may be changed to a true function in the near future.<P>
The scanner writes its <B>ECHO</B> output to the <I>yyout</I> global (default, stdout), which may be redefined by the user simply by assigning it to some other <B>FILE</B> pointer.<P>

<A NAME="sect9" HREF="#toc9"><H2><B>START</B> <B>CONDITIONS</B></H2></A>
<I>flex</I> provides a mechanism for conditionally activating rules. Any rule whose pattern is prefixed with &quot;&lt;sc&gt;&quot; will only be active when the scanner is in the start condition named &quot;sc". For example,<P>
<dl>
<dt>&lt;STRING&gt;[^"]* <dd>       { /* eat up the string body ... */ ... }<P>
</dd>
</dl>
will be active only when the scanner is in the &quot;STRING" start condition, and<P>
&lt;INITIAL,STRING,QUOTE&gt;\.        { /* handle an escape ... */ ...<BR>
 }<P>
will be active only when the current start condition is either &quot;INITIAL", &quot;STRING", or &quot;QUOTE".<P>
Start conditions are declared in the definitions (first) section of the input using unindented lines beginning with either <B>%s</B> or <B>%x</B> followed by a list of names. The former declares <I>inclusive</I> start conditions, the latter <I>exclusive</I> start conditions. A start condition is activated using the <B>BEGIN</B> action. Until the next <B>BEGIN</B> action is executed, rules with the given start condition will be active and rules with other start conditions will be inactive. If the start condition is <I>inclusive</I>, then rules with no start conditions at all will also be active. If it is <I>exclusive</I>, then <I>only</I> rules qualified with the start condition will be active. A set of rules contingent on the same exclusive start condition describe a scanner which is independent of any of the other rules in the <I>flex</I> input. Because of this, exclusive start conditions make it easy to specify &quot;miniscanners" which scan portions of the input that are syntactically different from the rest (e.g., comments).<P>
If the distinction between inclusive and exclusive start conditions is still a little vague, here's a simple example illustrating the connection between the two. The set of rules:<P>
%s example<BR>
 %%<BR>
 <dl>
<dt>&lt;example&gt;foo <dd>          /* do something */<P>
</dd>
</dl>
is equivalent to<P>
%x example<BR>
 %%<BR>
 <dl>
<dt>&lt;INITIAL,example&gt;foo <dd>/* do something */<P>
</dd>
</dl>
The default rule (to <B>ECHO</B> any unmatched character) remains active in start conditions.<P>
<B>BEGIN(0)</B> returns to the original state where only the rules with no start conditions are active. This state can also be referred to as the start-condition &quot;INITIAL", so <B>BEGIN(INITIAL)</B> is equivalent to <B>BEGIN(0).</B> (The parentheses around the start condition name are not required but are considered good style.)<P>
<B>BEGIN</B> actions can also be given as indented code at the beginning of the rules section. For example, the following will cause the scanner to enter the &quot;SPECIAL&quot; start condition whenever <I>yylex</I>() is called and the global variable <I>enter</I>_<I>special</I> is true:<P>
int enter_special;<P>
%x SPECIAL<BR>
 %%<BR>
 if ( enter_special )<BR>
 BEGIN(SPECIAL);<P>
&lt;SPECIAL&gt;blahblahblah<BR>
 ...more rules follow...<P>
To illustrate the uses of start conditions, here is a scanner which provides two different interpretations of a string like &quot;123.456". By default it will treat it as as three tokens, the integer &quot;123", a dot ('.'), and the integer &quot;456". But if the string is preceded earlier in the line by the string &quot;expect-floats&quot; it will treat it as a single token, the floating-point number 123.456:<P>
%{<BR>
 #include &lt;math.h&gt;<BR>
 %}<BR>
 %s expect<P>
%%<BR>
 <dl>
<dt>expect-floats <dd>       BEGIN(expect);<P>
</dd>
</dl>
<dl>
<dt>&lt;expect&gt;[0-9]+"."[0-9]+ <dd>     { printf( &quot;found a float, = %f\n", atof( yytext ) ); } </dd>
</dl>
<dl>
<dt>&lt;expect&gt;\n <dd>          { /* that's the end of the line, so * we need another &quot;expect-number" * before we'll recognize any more * numbers */ BEGIN(INITIAL); }<P>
</dd>
</dl>
<dl>
<dt>[0-9]+ <dd>     { printf( &quot;found an integer, = %d\n", atoi( yytext ) ); }<P>
</dd>
</dl>
<dl>
<dt>&quot;.&quot; <dd>        printf( &quot;found a dot\n&quot; );<P>
</dd>
</dl>
Here is a scanner which recognizes (and discards) C comments while maintaining a count of the current input line.<P>
%x comment<BR>
 %%<BR>
 int line_num = 1;<P>
<dl>
<dt>&quot;/*&quot; <dd>        BEGIN(comment);<P>
</dd>
</dl>
<dl>
<dt>&lt;comment&gt;[^*\n]* <dd>       /* eat anything that's not a `*' */ </dd>
</dl>
<dl>
<dt>&lt;comment&gt;"*"+[^*/\n]* <dd>/* eat up `*'s not followed by `/'s */ </dd>
</dl>
<dl>
<dt>&lt;comment&gt;\n <dd>            ++line_num; </dd>
</dl>
<dl>
<dt>&lt;comment&gt;"*"+"/&quot; <dd>       BEGIN(INITIAL);<P>
</dd>
</dl>
Note that start-conditions names are really integer values and can be stored as such. Thus, the above could be extended in the following fashion:<P>
%x comment foo<BR>
 %%<BR>
 int line_num = 1;<BR>
 int comment_caller;<P>
<dl>
<dt>&quot;/*&quot; <dd>        { comment_caller = INITIAL; BEGIN(comment); }<P>
</dd>
</dl>
<dl>
<dt>...<dd><P>
</dd>
</dl>
<dl>
<dt>&lt;foo&gt;"/*&quot; <dd>   { comment_caller = foo; BEGIN(comment); }<P>
</dd>
</dl>
<dl>
<dt>&lt;comment&gt;[^*\n]* <dd>       /* eat anything that's not a `*' */ </dd>
</dl>
<dl>
<dt>&lt;comment&gt;"*"+[^*/\n]* <dd>/* eat up `*'s not followed by `/'s */ </dd>
</dl>
<dl>
<dt>&lt;comment&gt;\n <dd>            ++line_num; </dd>
</dl>
<dl>
<dt>&lt;comment&gt;"*"+"/&quot; <dd>       BEGIN(comment_caller);<P>
</dd>
</dl>
One can then implement a &quot;stack&quot; of start conditions using an array of integers. (It is likely that such stacks will become a full-fledged <I>flex</I> feature in the future.) Note, though, that start conditions do not have their own namespace; %s's and %x's declare names in the same fashion as #define's.<P>

<A NAME="sect10" HREF="#toc10"><H2><B>MULTIPLE</B> <B>INPUT</B> <B>BUFFERS</B></H2></A>
Some scanners (such as those which support &quot;include&quot; files) require reading from several input streams. As <I>flex</I> scanners do a large amount of buffering, one cannot control where the next input will be read from by simply writing a <B>YY_INPUT</B> which is sensitive to the scanning context. <B>YY_INPUT</B> is only called when the scanner reaches the end of its buffer, which may be a long time after scanning a statement such as an &quot;include&quot; which requires switching the input source.<P>
To negotiate these sorts of problems, <I>flex</I> provides a mechanism for creating and switching between multiple input buffers. An input buffer is created by using:<P>
YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )<P>
which takes a <I>FILE</I> pointer and a size and creates a buffer associated with the given file and large enough to hold <I>size</I> characters (when in doubt, use <B>YY_BUF_SIZE</B> for the size). It returns a <B>YY_BUFFER_STATE</B> handle, which may then be passed to other routines:<P>
void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )<P>
switches the scanner's input buffer so subsequent tokens will come from <I>new</I>_<I>buffer</I>. Note that <B>yy_switch_to_buffer()</B> may be used by yywrap() to sets things up for continued scanning, instead of opening a new file and pointing <I>yyin</I> at it.<P>
void yy_delete_buffer( YY_BUFFER_STATE buffer )<P>
is used to reclaim the storage associated with a buffer.<P>
<B>yy_new_buffer()</B> is an alias for <B>yy_create_buffer(),</B> provided for compatibility with the C++ use of <I>new</I> and <I>delete</I> for creating and destroying dynamic objects.<P>
Finally, the    <B>YY_CURRENT_BUFFER</B>    macro    returns    a <B>YY_BUFFER_STATE</B> handle to the current buffer.<P>
Here is an example of using these features for writing a scanner which expands include files (the <B>&lt;&lt;EOF&gt;&gt;</B> feature is discussed below):<P>
/* the &quot;incl&quot; state is used for picking up the name * of an include file<BR>
 */<BR>
 %x incl<P>
%{<BR>
 #define MAX_INCLUDE_DEPTH 10<BR>
 YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH]; int include_stack_ptr = 0;<BR>
 %}<P>
%%<BR>
 <dl>
<dt>include <dd>            BEGIN(incl);<P>
</dd>
</dl>
<dl>
<dt>[a-z]+ <dd>             ECHO; </dd>
</dl>
<dl>
<dt>[^a-z\n]*\n? <dd>       ECHO;<P>
</dd>
</dl>
<dl>
<dt>&lt;incl&gt;[ \t]* <dd>     /* eat the whitespace */ </dd>
</dl>
<dl>
<dt>&lt;incl&gt;[^ \t\n]+ <dd>{ /* got the include file name */ if ( include_stack_ptr &gt;= MAX_INCLUDE_DEPTH ) { fprintf( stderr, &quot;Includes nested too deeply&quot; ); exit( 1 ); }<P>
</dd>
</dl>
include_stack[include_stack_ptr++] = YY_CURRENT_BUFFER;<P>
yyin = fopen( yytext, &quot;r&quot; );<P>
if ( ! yyin )<BR>
 error( ... );<P>
yy_switch_to_buffer(<BR>
 yy_create_buffer( yyin, YY_BUF_SIZE ) );<P>
BEGIN(INITIAL);<BR>
 }<P>
&lt;&lt;EOF&gt;&gt; {<BR>
 if ( --include_stack_ptr &lt; 0 ) {<BR>
 yyterminate();<BR>
 }<P>
else<BR>
 yy_switch_to_buffer(<BR>
 include_stack[include_stack_ptr] ); }<P>

<A NAME="sect11" HREF="#toc11"><H2><B>END-OF-FILE</B> <B>RULES</B></H2></A>
The special rule &quot;&lt;&lt;EOF&gt;&gt;&quot; indicates actions which are to be taken when an end-of-file is encountered and yywrap() returns non-zero (i.e., indicates no further files to process). The action must finish by doing one of four things:<P>
<dl>
<dt>- <dd>   the special <B>YY_NEW_FILE</B> action, if <I>yyin</I> has been pointed at a new file to process;<P>
</dd>
</dl>
<dl>
<dt>- <dd>   a <I>return</I> statement;<P>
</dd>
</dl>
<dl>
<dt>- <dd>   the special <B>yyterminate()</B> action;<P>
</dd>
</dl>
<dl>
<dt>- <dd>   or,    switching    to    a    new     buffer     using <B>yy_switch_to_buffer()</B> as shown in the example above.<P>
</dd>
</dl>
&lt;&lt;EOF&gt;&gt; rules may not be used with other patterns; they may only be qualified with a list of start conditions. If an unqualified &lt;&lt;EOF&gt;&gt; rule is given, it applies to <I>all</I> start conditions which do not already have &lt;&lt;EOF&gt;&gt; actions. To specify an &lt;&lt;EOF&gt;&gt; rule for only the initial start condition, use<P>
&lt;INITIAL&gt;&lt;&lt;EOF&gt;&gt;<P>
These rules are useful for catching things like unclosed comments. An example:<P>
%x quote<BR>
 %%<P>
<dl>
<dt>...other rules for dealing with quotes...<dd><P>
</dd>
</dl>
&lt;quote&gt;&lt;&lt;EOF&gt;&gt; {<BR>
 error( &quot;unterminated quote&quot; ); yyterminate();<BR>
 }<BR>
 &lt;&lt;EOF&gt;&gt; {<BR>
 if ( *++filelist )<BR>
 {<BR>
 yyin = fopen( *filelist, &quot;r&quot; ); YY_NEW_FILE;<BR>
 }<BR>
 else<BR>
 yyterminate();<BR>
 }<P>

<A NAME="sect12" HREF="#toc12"><H2><B>MISCELLANEOUS</B> <B>MACROS</B></H2></A>
The macro YY_USER_ACTION can be redefined to provide an action which is always executed prior to the matched rule's action. For example, it could be #define'd to call a routine to convert yytext to lower-case.<P>
The macro <B>YY_USER_INIT</B> may be redefined to provide an action which is always executed before the first scan (and before the scanner's internal initializations are done). For example, it could be used to call a routine to read in a data table or open a logging file.<P>
In the generated scanner, the actions are all gathered in one large switch statement and separated using <B>YY_BREAK,</B> which may be redefined. By default, it is simply a &quot;break", to separate each rule's action from the following rule's. Redefining <B>YY_BREAK</B> allows, for example, C++ users to #define YY_BREAK to do nothing (while being very careful that every rule ends with a &quot;break&quot; or a &quot;return"!) to avoid suffering from unreachable statement warnings where because a rule's action ends with &quot;return", the <B>YY_BREAK</B> is inaccessible.<P>

<A NAME="sect13" HREF="#toc13"><H2><B>INTERFACING</B> <B>WITH</B> <B>YACC</B></H2></A>
One of the main uses of <I>flex</I> is as a companion to the <I>yacc</I> parser-generator. <I>yacc</I> parsers expect to call a routine named <B>yylex()</B> to find the next input token. The routine is supposed to return the type of the next token as well as putting any associated value in the global <B>yylval.</B> To use <I>flex</I> with <I>yacc</I>, one specifies the <B>-d</B> option to <I>yacc</I> to instruct it to generate the file <B>y.tab.h</B> containing definitions of all the <B>%tokens</B> appearing in the <I>yacc</I> input. This file is then included in the <I>flex</I> scanner. For example, if one of the tokens is &quot;TOK_NUMBER", part of the scanner might look like:<P>
%{<BR>
 #include &quot;y.tab.h"<BR>
 %}<P>
%%<P>
<dl>
<dt>[0-9]+ <dd>       yylval = atoi( yytext ); return TOK_NUMBER;<P>
</dd>
</dl>

<A NAME="sect14" HREF="#toc14"><H2><B>TRANSLATION</B> <B>TABLE</B></H2></A>
In the name of POSIX compliance, <I>flex</I> supports a <I>translation</I> <I>table</I> for mapping input characters into groups. The table is specified in the first section, and its format looks like:<P>
%t<BR>
 <dl>
<dt>1 <dd>       abcd </dd>
</dl>
<dl>
<dt>2        ABCDEFGHIJKLMNOPQRSTUVWXYZ<dd> </dd>
</dl>
<dl>
<dt>52 <dd>      0123456789 </dd>
</dl>
<dl>
<dt>6 <dd>       \t\ \n %t<P>
</dd>
</dl>
This example specifies that the characters `a', `b', `c', and `d' are to all be lumped into group #1, upper-case letters in group #2, digits in group #52, tabs, blanks, and newlines into group #6, and <I>no</I> <I>other</I> <I>characters</I> <I>will</I> <I>appear</I> <I>in</I> <I>the</I> <I>patterns</I>. The group numbers are actually disregarded by <I>flex</I>; <B>%t</B> serves, though, to lump characters together. Given the above table, for example, the pattern &quot;a(AA)*5&quot; is equivalent to &quot;d(ZQ)*0". They both say, &quot;match any character in group #1, followed by zero-or-more pairs of characters from group #2, followed by a character from group #52." Thus <B>%t</B> provides a crude way for introducing equivalence classes into the scanner specification.<P>
Note that the <B>-i</B> option (see below) coupled with the equivalence classes which <I>flex</I> automatically generates take care of virtually all the instances when one might consider using <B>%t.</B> But what the hell, it's there if you want it.<P>

<A NAME="sect15" HREF="#toc15"><H2><B>OPTIONS</B></H2></A>
<I>flex</I> has the following options:<P>
<dl>
<dt><B>-b</B> <dd>Generate backtracking information to <I>lex</I>.<I>backtrack</I>. This is a list of scanner states which require backtracking and the input characters on which they do so. By adding rules one can remove backtracking states. If all backtracking states are eliminated and <B>-f</B> or <B>-F</B> is used, the generated scanner will run faster (see the <B>-p</B> flag). Only users who wish to squeeze every last cycle out of their scanners need worry about this option. (See the section on PERFORMANCE CONSIDERATIONS below.)<P>
</dd>
</dl>
<dl>
<dt><B>-c</B> <dd>is a do-nothing, deprecated option included for POSIX compliance.<P>
</dd>
</dl>
<B>NOTE:</B> in previous releases of <I>flex</I> <B>-c</B> specified tablecompression options. This functionality is now given by the <B>-C</B> flag. To ease the the impact of this change, when <I>flex</I> encounters <B>-c,</B> it currently issues a warning message and assumes that <B>-C</B> was desired instead. In the future this &quot;promotion&quot; of <B>-c</B> to <B>-C</B> will go away in the name of full POSIX compliance (unless the POSIX meaning is removed first).<P>
<dl>
<dt><B>-d</B> <dd>makes the generated scanner run in <I>debug</I> mode. Whenever a pattern is recognized and the global <B>yy_flex_debug</B> is non-zero (which is the default), the scanner will write to <I>stderr</I> a line of the form:<P>
</dd>
</dl>
<dl>
<dt>--accepting rule at line 53 ("the matched text")<dd><P>
</dd>
</dl>
The line number refers to the location of the rule in the file defining the scanner (i.e., the file that was fed to flex). Messages are also generated when the scanner backtracks, accepts the default rule, reaches the end of its input buffer (or encounters a NUL; at this point, the two look the same as far as the scanner's concerned), or reaches an end-of-file.<P>
<dl>
<dt><B>-f</B> <dd>specifies (take your pick) <I>full</I> <I>table</I> or <I>fast</I> <I>scanner</I>. No table compression is done. The result is large but fast. This option is equivalent to <B>-Cf</B> (see below).<P>
</dd>
</dl>
<dl>
<dt><B>-i</B> <dd>instructs <I>flex</I> to generate a <I>case</I>-<I>insensitive</I> scanner. The case of letters given in the <I>flex</I> input patterns will be ignored, and tokens in the input will be matched regardless of case. The matched text given in <I>yytext</I> will have the preserved case (i.e., it will not be folded).<P>
</dd>
</dl>
<dl>
<dt><B>-n</B> <dd>is another do-nothing, deprecated option included only for POSIX compliance.<P>
</dd>
</dl>
<dl>
<dt><B>-p</B> <dd>generates a performance report to stderr. The report consists of comments regarding features of the <I>flex</I> input file which will cause a loss of performance in the resulting scanner. Note that the use of <I>REJECT</I> and variable trailing context (see the BUGS section in <A HREF="http://www.stna7.stna.dgac.fr/cgi-bin/man2html?flex?1">flex(1)</A>) entails a substantial performance penalty; use of <I>yymore</I>(), the <B>^</B> operator, and the <B>-I</B> flag entail minor performance penalties.<P>
</dd>
</dl>
<dl>
<dt><B>-s</B> <dd>causes the <I>default</I> <I>rule</I> (that unmatched scanner input is echoed to <I>stdout</I>) to be suppressed. If the scanner encounters input that does not match any of its rules, it aborts with an error. This option is useful for finding holes in a scanner's rule set.<P>
</dd>
</dl>
<dl>
<dt><B>-t</B> <dd>instructs <I>flex</I> to write the scanner it generates to standard output instead of <B>lex.yy.c.</B><P>
</dd>
</dl>
<dl>
<dt><B>-v</B> <dd>specifies that <I>flex</I> should write to <I>stderr</I> a summary of statistics regarding the scanner it generates. Most of the statistics are meaningless to the casual <I>flex</I> user, but the first line identifies the version of <I>flex</I>, which is useful for figuring out where you stand with respect to patches and new releases, and the next two lines give the date when the scanner was created and a summary of the flags which were in effect.<P>
</dd>
</dl>
<dl>
<dt><B>-F</B> <dd>specifies that the <I>fast</I> scanner table representation should be used. This representation is about as fast as the full table representation (-<I>f</I>), and for some sets of patterns will be considerably smaller (and for others, larger). In general, if the pattern set contains both &quot;keywords&quot; and a catch-all, &quot;identifier" rule, such as in the set:<P>
</dd>
</dl>
<dl>
<dt>&quot;case&quot; <dd>   return TOK_CASE; &quot;switch&quot; return TOK_SWITCH; ... &quot;default&quot; return TOK_DEFAULT; </dd>
</dl>
<dl>
<dt>[a-z]+ <dd>   return TOK_ID;<P>
</dd>
</dl>
then you're better off using the full table representation. If only the &quot;identifier&quot; rule is present and you then use a hash table or some such to detect the keywords, you're better off using -<I>F</I>.<P>
This option is equivalent to <B>-CF</B> (see below).<P>
<dl>
<dt><B>-I</B> <dd>instructs <I>flex</I> to generate an <I>interactive</I> scanner. Normally, scanners generated by <I>flex</I> always look ahead one character before deciding that a rule has been matched. At the cost of some scanning overhead, <I>flex</I> will generate a scanner which only looks ahead when needed. Such scanners are called <I>interactive</I> because if you want to write a scanner for an interactive system such as a command shell, you will probably want the user's input to be terminated with a newline, and without <B>-I</B> the user will have to type a character in addition to the newline in order to have the newline recognized. This leads to dreadful interactive performance.<P>
</dd>
</dl>
If all this seems to confusing, here's the general rule: if a human will be typing in input to your scanner, use <B>-I,</B> otherwise don't; if you don't care about squeezing the utmost performance from your scanner and you don't want to make any assumptions about the input to your scanner, use <B>-I.</B><P>
Note, <B>-I</B> cannot be used in conjunction with <I>full</I> or <I>fast</I> <I>tables</I>, i.e., the <B>-f,</B> <B>-F,</B> <B>-Cf,</B> or <B>-CF</B> flags.<P>
<dl>
<dt><B>-L</B> <dd>instructs <I>flex</I> not to generate <B>#line</B> directives. Without this option, <I>flex</I> peppers the generated scanner with #line directives so error messages in the actions will be correctly located with respect to the original <I>flex</I> input file, and not to the fairly meaningless line numbers of <B>lex.yy.c.</B> (Unfortunately <I>flex</I> does not presently generate the necessary directives to &quot;retarget" the line numbers for those parts of <B>lex.yy.c</B> which it generated. So if there is an error in the generated code, a meaningless line number is reported.)<P>
</dd>
</dl>
<dl>
<dt><B>-T</B> <dd>makes <I>flex</I> run in <I>trace</I> mode. It will generate a lot of messages to <I>stdout</I> concerning the form of the input and the resultant non-deterministic and deterministic finite automata. This option is mostly for use in maintaining <I>flex</I>.<P>
</dd>
</dl>
<dl>
<dt><B>-8</B> <dd>instructs <I>flex</I> to generate an 8-bit scanner, i.e., one which can recognize 8-bit characters. On some sites, <I>flex</I> is installed with this option as the default. On others, the default is 7-bit characters. To see which is the case, check the verbose <B>(-v)</B> output for &quot;equivalence classes created". If the denominator of the number shown is 128, then by default <I>flex</I> is generating 7-bit characters. If it is 256, then the default is 8-bit characters and the <B>-8</B> flag is not required (but may be a good idea to keep the scanner specification portable). Feeding a 7-bit scanner 8-bit characters will result in infinite loops, bus errors, or other such fireworks, so when in doubt, use the flag. Note that if equivalence classes are used, 8-bit scanners take only slightly more table space than 7-bit scanners (128 bytes, to be exact); if equivalence classes are not used, however, then the tables may grow up to twice their 7-bit size.<P>
</dd>
</dl>
<dl>
<dt><B>-C[efmF]</B><dd> controls the degree of table compression. <B>-Ce</B> directs <I>flex</I> to construct <I>equivalence</I> <I>classes</I>, i.e., sets of characters which have identical lexical properties (for example, if the only appearance of digits in the <I>flex</I> input is in the character class &quot;[0-9]&quot; then the digits `0', `1', ..., `9' will all be put in the same equivalence class). Equivalence classes usually give dramatic reductions in the final table/object file sizes (typically a factor of 2-5) and are pretty cheap performance-wise (one array look-up per character scanned).<P>
</dd>
</dl>
<dl>
<dt><B>-Cf</B> specifies that the <I>full</I> scanner <dd>tables should be generated - <I>flex</I> should not compress the tables by taking advantages of similar transition functions for different states.<P>
</dd>
</dl>
<dl>
<dt><B>-CF</B> specifies that the alternate fast scanner representation<dd> (described above under the <B>-F</B> flag) should be used.<P>
</dd>
</dl>
<dl>
<dt><B>-Cm</B> directs <I>flex</I> to construct <I>meta</I>-<I>equivalence</I> <I>classes</I>,<dd> which are sets of equivalence classes (or characters, if equivalence classes are not being used) that are commonly used together. Meta-equivalence classes are often a big win when using compressed tables, but they have a moderate performance impact (one or two &quot;if" tests and one array look-up per character scanned).<P>
</dd>
</dl>
A lone <B>-C</B> specifies that the scanner tables should be compressed but neither equivalence classes nor metaequivalence classes should be used.<P>
The options <B>-Cf</B> or <B>-CF</B> and <B>-Cm</B> do not make sense together - there is no opportunity for meta-equivalence classes if the table is not being compressed. Otherwise the options may be freely mixed.<P>
The default setting is <B>-Cem,</B> which specifies that <I>flex</I> should generate equivalence classes and metaequivalence classes. This setting provides the highest degree of table compression. You can trade off faster-executing scanners at the cost of larger tables with the following generally being true:<P>
slowest &amp; smallest<BR>
 -Cem<BR>
 -Cm<BR>
 -Ce<BR>
 -C<BR>
 -C{f,F}e<BR>
 -C{f,F}<BR>
 fastest &amp; largest<P>
Note that scanners with the smallest tables are usually generated and compiled the quickest, so during development you will usually want to use the default, maximal compression.<P>
<dl>
<dt><B>-Cfe</B> is often a good compromise between speed and <dd>size for production scanners.<P>
</dd>
</dl>
<dl>
<dt><B>-C</B> options are not cumulative; <dd>whenever the flag is encountered, the previous -C settings are forgotten.<P>
</dd>
</dl>
<dl>
<dt><B>-Sskeleton_file</B><dd> overrides the default skeleton file from which <I>flex</I> constructs its scanners. You'll never need this option unless you are doing <I>flex</I> maintenance or development.<P>
</dd>
</dl>

<A NAME="sect16" HREF="#toc16"><H2><B>PERFORMANCE</B> <B>CONSIDERATIONS</B></H2></A>
The main design goal of <I>flex</I> is that it generate highperformance scanners. It has been optimized for dealing well with large sets of rules. Aside from the effects of table compression on scanner speed outlined above, there are a number of options/actions which degrade performance. These are, from most expensive to least:<P>
<dl>
<dt>REJECT<dd><P>
</dd>
</dl>
pattern sets that require backtracking arbitrary trailing context<P>
`^' beginning-of-line operator<BR>
 yymore()<P>
with the first three all being quite expensive and the last two being quite cheap.<P>
<B>REJECT</B> should be avoided at all costs when performance is important. It is a particularly expensive option.<P>
Getting rid of backtracking is messy and often may be an enormous amount of work for a complicated scanner. In principal, one begins by using the <B>-b</B> flag to generate a <I>lex</I>.<I>backtrack</I> file. For example, on the input<P>
%%<BR>
 <dl>
<dt>foo <dd>       return TOK_KEYWORD; </dd>
</dl>
<dl>
<dt>foobar <dd>    return TOK_KEYWORD;<P>
</dd>
</dl>
the file looks like:<P>
State #6 is non-accepting associated<BR>
 rule line numbers:<BR>
 <dl>
<dt>2 <dd>      3<P>
</dd>
</dl>
out-transitions: [ o ]<BR>
 jam-transitions: EOF [ \001-n p-\177 ]<P>
State #8 is non-accepting associated<BR>
 rule line numbers:<BR>
 3<BR>
 out-transitions: [ a ]<BR>
 jam-transitions: EOF [ \001-` b-\177 ]<P>
State #9 is non-accepting associated<BR>
 rule line numbers:<BR>
 3<BR>
 out-transitions: [ r ]<BR>
 jam-transitions: EOF [ \001-q s-\177 ]<P>
Compressed tables always backtrack.<P>
The first few lines tell us that there's a scanner state in which it can make a transition on an `o' but not on any other character, and that in that state the currently scanned text does not match any rule. The state occurs when trying to match the rules found at lines 2 and 3 in the input file. If the scanner is in that state and then reads something other than an `o', it will have to backtrack to find a rule which is matched. With a bit of headscratching one can see that this must be the state it's in when it has seen &quot;fo". When this has happened, if anything other than another `o' is seen, the scanner will have to back up to simply match the `f' (by the default rule).<P>
The comment regarding State #8 indicates there's a problem when &quot;foob&quot; has been scanned. Indeed, on any character other than a `b', the scanner will have to back up to accept &quot;foo". Similarly, the comment for State #9 concerns when &quot;fooba&quot; has been scanned.<P>
The final comment reminds us that there's no point going to all the trouble of removing backtracking from the rules unless we're using <B>-f</B> or <B>-F,</B> since there's no performance gain doing so with compressed scanners.<P>
The way to remove the backtracking is to add &quot;error&quot; rules:<P>
%%<BR>
 <dl>
<dt>foo <dd>        return TOK_KEYWORD; </dd>
</dl>
<dl>
<dt>foobar <dd>     return TOK_KEYWORD;<P>
</dd>
</dl>
<dl>
<dt>fooba <dd>      | </dd>
</dl>
<dl>
<dt>foob <dd>       | </dd>
</dl>
<dl>
<dt>fo <dd>         { /* false alarm, not really a keyword */ return TOK_ID; }<P>
</dd>
</dl>
Eliminating backtracking among a list of keywords can also be done using a &quot;catch-all&quot; rule:<P>
%%<BR>
 <dl>
<dt>foo <dd>        return TOK_KEYWORD; </dd>
</dl>
<dl>
<dt>foobar <dd>     return TOK_KEYWORD;<P>
</dd>
</dl>
<dl>
<dt>[a-z]+ <dd>     return TOK_ID;<P>
</dd>
</dl>
This is usually the best solution when appropriate.<P>
Backtracking messages tend to cascade. With a complicated set of rules it's not uncommon to get hundreds of messages. If one can decipher them, though, it often only takes a dozen or so rules to eliminate the backtracking (though it's easy to make a mistake and have an error rule accidentally match a valid token. A possible future <I>flex</I> feature will be to automatically add rules to eliminate backtracking).<P>
<I>Variable</I> trailing context (where both the leading and trailing parts do not have a fixed length) entails almost the same performance loss as <I>REJECT</I> (i.e., substantial). So when possible a rule like:<P>
%%<BR>
 mouse|rat/(cat|dog) run();<P>
is better written:<P>
%%<BR>
 <dl>
<dt>mouse/cat|dog <dd>        run(); </dd>
</dl>
<dl>
<dt>rat/cat|dog <dd>          run();<P>
</dd>
</dl>
or as<P>
%%<BR>
 <dl>
<dt>mouse|rat/cat <dd>        run(); </dd>
</dl>
<dl>
<dt>mouse|rat/dog <dd>        run();<P>
</dd>
</dl>
Note that here the special `|' action does <I>not</I> provide any savings, and can even make things worse (see <B>BUGS</B> in <A HREF="http://www.stna7.stna.dgac.fr/cgi-bin/man2html?flex?1">flex(1)</A>).<P>
Another area where the user can increase a scanner's performance (and one that's easier to implement) arises from the fact that the longer the tokens matched, the faster the scanner will run. This is because with long tokens the processing of most input characters takes place in the (short) inner scanning loop, and does not often have to go through the additional work of setting up the scanning environment (e.g., <B>yytext)</B> for the action. Recall the scanner for C comments:<P>
%x comment<BR>
 %%<BR>
 int line_num = 1;<P>
<dl>
<dt>&quot;/*&quot; <dd>        BEGIN(comment);<P>
</dd>
</dl>
&lt;comment&gt;[^*\n]*<BR>
 &lt;comment&gt;"*"+[^*/\n]*<BR>
 <dl>
<dt>&lt;comment&gt;\n <dd>            ++line_num; </dd>
</dl>
<dl>
<dt>&lt;comment&gt;"*"+"/&quot; <dd>       BEGIN(INITIAL);<P>
</dd>
</dl>
This could be sped up by writing it as:<P>
%x comment<BR>
 %%<BR>
 int line_num = 1;<P>
<dl>
<dt>&quot;/*&quot; <dd>        BEGIN(comment);<P>
</dd>
</dl>
&lt;comment&gt;[^*\n]*<BR>
 <dl>
<dt>&lt;comment&gt;[^*\n]*\n <dd>     ++line_num; &lt;comment&gt;"*"+[^*/\n]* &lt;comment&gt;"*"+[^*/\n]*\n ++line_num; </dd>
</dl>
<dl>
<dt>&lt;comment&gt;"*"+"/&quot; <dd>       BEGIN(INITIAL);<P>
</dd>
</dl>
Now instead of each newline requiring the processing of another action, recognizing the newlines is &quot;distributed" over the other rules to keep the matched text as long as possible. Note that <I>adding</I> rules does <I>not</I> slow down the scanner! The speed of the scanner is independent of the number of rules or (modulo the considerations given at the beginning of this section) how complicated the rules are with regard to operators such as `*' and `|'.<P>
A final example in speeding up a scanner: suppose you want to scan through a file containing identifiers and keywords, one per line and with no other extraneous characters, and recognize all the keywords. A natural first approach is:<P>
%%<BR>
 <dl>
<dt>asm <dd>     | </dd>
</dl>
<dl>
<dt>auto <dd>    | </dd>
</dl>
<dl>
<dt>break <dd>   | ... etc ... volatile | </dd>
</dl>
<dl>
<dt>while <dd>   /* it's a keyword */<P>
</dd>
</dl>
<dl>
<dt>.|\n <dd>    /* it's not a keyword */<P>
</dd>
</dl>
To eliminate the back-tracking, introduce a catch-all rule:<P>
%%<BR>
 <dl>
<dt>asm <dd>     | </dd>
</dl>
<dl>
<dt>auto <dd>    | </dd>
</dl>
<dl>
<dt>break <dd>   | ... etc ... volatile | </dd>
</dl>
<dl>
<dt>while <dd>   /* it's a keyword */<P>
</dd>
</dl>
[a-z]+ |<BR>
 <dl>
<dt>.|\n <dd>    /* it's not a keyword */<P>
</dd>
</dl>
Now, if it's guaranteed that there's exactly one word per line, then we can reduce the total number of matches by a half by merging in the recognition of newlines with that of the other tokens:<P>
%%<BR>
 <dl>
<dt>asm\n <dd>   | auto\n | break\n | ... etc ... volatile\n | while\n /* it's a keyword */<P>
</dd>
</dl>
[a-z]+\n |<BR>
 <dl>
<dt>.|\n <dd>    /* it's not a keyword */<P>
</dd>
</dl>
One has to be careful here, as we have now reintroduced backtracking into the scanner. In particular, while <I>we</I> know that there will never be any characters in the input stream other than letters or newlines, <I>flex</I> can't figure this out, and it will plan for possibly needing backtracking when it has scanned a token like &quot;auto&quot; and then the next character is something other than a newline or a letter. Previously it would then just match the &quot;auto&quot; rule and be done, but now it has no &quot;auto&quot; rule, only a &quot;auto\n&quot; rule. To eliminate the possibility of backtracking, we could either duplicate all rules but without final newlines, or, since we never expect to encounter such an input and therefore don't how it's classified, we can introduce one more catch-all rule, this one which doesn't include a newline:<P>
%%<BR>
 <dl>
<dt>asm\n <dd>   | auto\n | break\n | ... etc ... volatile\n | while\n /* it's a keyword */ [a-z]+\n | [a-z]+ | </dd>
</dl>
<dl>
<dt>.|\n <dd>    /* it's not a keyword */<P>
</dd>
</dl>
Compiled with <B>-Cf,</B> this is about as fast as one can get a <I>flex</I> scanner to go for this particular problem.<P>
A final note: <I>flex</I> is slow when matching NUL's, particularly when a token contains multiple NUL's. It's best to write rules which match <I>short</I> amounts of text if it's anticipated that the text will often include NUL's.<P>

<A NAME="sect17" HREF="#toc17"><H2><B>INCOMPATIBILITIES</B> <B>WITH</B> <B>LEX</B> <B>AND</B> <B>POSIX</B></H2></A>
<I>flex</I> is a rewrite of the Unix <I>lex</I> tool (the two implementations do not share any code, though), with some extensions and incompatibilities, both of which are of concern to those who wish to write scanners acceptable to either implementation. At present, the POSIX <I>lex</I> draft is very close to the original <I>lex</I> implementation, so some of these incompatibilities are also in conflict with the POSIX draft. But the intent is that except as noted below, <I>flex</I> as it presently stands will ultimately be POSIX conformant (i.e., that those areas of conflict with the POSIX draft will be resolved in <I>flex</I>'<I>s</I> favor). Please bear in mind that all the comments which follow are with regard to the POSIX <I>draft</I> standard of Summer 1989, and not the final document (or subsequent drafts); they are included so <I>flex</I> users can be aware of the standardization issues and those areas where <I>flex</I> may in the near future undergo changes incompatible with its current definition.<P>
<I>flex</I> is fully compatible with <I>lex</I> with the following exceptions:<P>
<dl>
<dt>- <dd>   The undocumented <I>lex</I> scanner internal variable <B>yylineno</B> is not supported. It is difficult to support this option efficiently, since it requires examining every character scanned and reexamining the characters when the scanner backs up. Things get more complicated when the end of buffer or file is reached or a NUL is scanned (since the scan must then be restarted with the proper line number count), or the user uses the yyless(), unput(), or REJECT actions, or the multiple input buffer functions.<P>
</dd>
</dl>
The fix is to add rules which, upon seeing a newline, increment yylineno. This is usually an easy process, though it can be a drag if some of the patterns can match multiple newlines along with other characters.<P>
yylineno is not part of the POSIX draft.<P>
<dl>
<dt>- <dd>   The <B>input()</B> routine is not redefinable, though it may be called to read characters following whatever has been matched by a rule. If <B>input()</B> encounters an endof-file the normal <B>yywrap()</B> processing is done. A ``real'' end-of-file is returned by <B>input()</B> as <I>EOF</I>.<P>
</dd>
</dl>
Input is instead controlled by redefining the <B>YY_INPUT</B> macro.<P>
The <I>flex</I> restriction that <B>input()</B> cannot be redefined is in accordance with the POSIX draft, but <B>YY_INPUT</B> has not yet been accepted into the draft (and probably won't; it looks like the draft will simply not specify any way of controlling the scanner's input other than by making an initial assignment to <I>yyin</I>).<P>
<dl>
<dt>-    <dd><I>flex</I> scanners do not use stdio for input. Because of this, when writing an interactive scanner one must explicitly call fflush() on the stream associated with the terminal after writing out a prompt. With <I>lex</I> such writes are automatically flushed since <I>lex</I> scanners use <B>getchar()</B> for their input. Also, when writing interactive scanners with <I>flex</I>, the <B>-I</B> flag must be used.<P>
</dd>
</dl>
<dl>
<dt>-    <dd><I>flex</I> scanners are not as reentrant as <I>lex</I> scanners. In particular, if you have an interactive scanner and an interrupt handler which long-jumps out of the scanner, and the scanner is subsequently called again, you may get the following message:<P>
</dd>
</dl>
fatal flex scanner internal error--end of buffer missed<P>
To reenter the scanner, first use<P>
yyrestart( yyin );<P>
<dl>
<dt>-    <B>output()</B> is not supported. Output from the <B>ECHO</B> macro<dd> is done to the file-pointer <I>yyout</I> (default <I>stdout</I>).<P>
</dd>
</dl>
The POSIX draft mentions that an <B>output()</B> routine exists but currently gives no details as to what it does.<P>
<dl>
<dt>-   <dd> <I>lex</I> does not support exclusive start conditions (%x), though they are in the current POSIX draft.<P>
</dd>
</dl>
<dl>
<dt>- <dd>   When definitions are expanded, <I>flex</I> encloses them in parentheses. With lex, the following:<P>
</dd>
</dl>
<dl>
<dt>NAME <dd>   [A-Z][A-Z0-9]* %% </dd>
</dl>
<dl>
<dt>foo{NAME}? <dd>     printf( &quot;Found it\n&quot; ); %%<P>
</dd>
</dl>
will not match the string &quot;foo&quot; because when the macro is expanded the rule is equivalent to &quot;foo[A-Z][A-Z09]*?" and the precedence is such that the `?' is associated with &quot;[A-Z0-9]*". With <I>flex</I>, the rule will be expanded to &quot;foo([A-Z][A-Z0-9]*)?&quot; and so the string &quot;foo&quot; will match. Note that because of this, the <B>^,</B> <B>$,</B> <B>&lt;s&gt;,</B> <B>/,</B> and <B>&lt;&lt;EOF&gt;&gt;</B> operators cannot be used in a <I>flex</I> definition.<P>
The POSIX draft interpretation is the same as <I>flex</I>'<I>s</I>.<P>
<dl>
<dt>- <dd>   To specify a character class which matches anything but a left bracket (']'), in <I>lex</I> one can use &quot;[^]]&quot; but with <I>flex</I> one must use &quot;[^\]]". The latter works with <I>lex</I>, too.<P>
</dd>
</dl>
<dl>
<dt>- <dd>   The <I>lex</I> <B>%r</B> (generate a Ratfor scanner) option is not supported. It is not part of the POSIX draft.<P>
</dd>
</dl>
<dl>
<dt>- <dd>   If you are providing your own yywrap() routine, you must include a &quot;#undef yywrap&quot; in the definitions section (section 1). Note that the &quot;#undef&quot; will have to be enclosed in %{}'s.<P>
</dd>
</dl>
The POSIX draft specifies that yywrap() is a function and this is very unlikely to change; so <I>flex</I> <I>users</I> <I>are</I> <I>warned</I> that <B>yywrap()</B> is likely to be changed to a function in the near future.<P>
<dl>
<dt>- <dd>   After a call to <B>unput(),</B> <I>yytext</I> and <I>yyleng</I> are undefined until the next token is matched. This is not the case with <I>lex</I> or the present POSIX draft.<P>
</dd>
</dl>
<dl>
<dt>- <dd>   The precedence of the <B>{}</B> (numeric range) operator is different. <I>lex</I> interprets &quot;abc{1,3}&quot; as &quot;match one, two, or three occurrences of `abc'", whereas <I>flex</I> interprets it as &quot;match `ab' followed by one, two, or three occurrences of `c'". The latter is in agreement with the current POSIX draft.<P>
</dd>
</dl>
<dl>
<dt>- <dd>   The precedence of the <B>^</B> operator is different. <I>lex</I> interprets &quot;^foo|bar&quot; as &quot;match either `foo' at the beginning of a line, or `bar' anywhere", whereas <I>flex</I> interprets it as &quot;match either `foo' or `bar' if they come at the beginning of a line". The latter is in agreement with the current POSIX draft.<P>
</dd>
</dl>
<dl>
<dt>- <dd>   To refer to yytext outside of the scanner source file, the correct definition with <I>flex</I> is &quot;extern char *yytext&quot; rather than &quot;extern char yytext[]". This is contrary to the current POSIX draft but a point on which <I>flex</I> will not be changing, as the array representation entails a serious performance penalty. It is hoped that the POSIX draft will be emended to support the <I>flex</I> variety of declaration (as this is a fairly painless change to require of <I>lex</I> users).<P>
</dd>
</dl>
<dl>
<dt>-    <dd><I>yyin</I> is <I>initialized</I> by <I>lex</I> to be <I>stdin</I>; <I>flex</I>, on the other hand, initializes <I>yyin</I> to NULL and then <I>assigns</I> it to <I>stdin</I> the first time the scanner is called, providing <I>yyin</I> has not already been assigned to a non-NULL value. The difference is subtle, but the net effect is that with <I>flex</I> scanners, <I>yyin</I> does not have a valid value until the scanner has been called.<P>
</dd>
</dl>
<dl>
<dt>- <dd>   The special table-size declarations such as <B>%a</B> supported by <I>lex</I> are not required by <I>flex</I> scanners; <I>flex</I> ignores them.<P>
</dd>
</dl>
<dl>
<dt>- <dd>   The name FLEX_SCANNER is #define'd so scanners may be written for use with either <I>flex</I> or <I>lex</I>.<P>
</dd>
</dl>
The following <I>flex</I> features are not included in <I>lex</I> or the POSIX draft standard:<P>
yyterminate()<BR>
 &lt;&lt;EOF&gt;&gt;<BR>
 YY_DECL<BR>
 #line directives<BR>
 %{}'s around actions<BR>
 yyrestart()<BR>
 comments beginning with `#' (deprecated) multiple actions on a line<P>
This last feature refers to the fact that with <I>flex</I> you can put multiple actions on the same line, separated with semicolons, while with <I>lex</I>, the following<P>
<dl>
<dt>foo <dd>   handle_foo(); ++num_foos_seen;<P>
</dd>
</dl>
is (rather surprisingly) truncated to<P>
<dl>
<dt>foo <dd>   handle_foo();<P>
</dd>
</dl>
<I>flex</I> does not truncate the action. Actions that are not enclosed in braces are simply terminated at the end of the line.<P>

<A NAME="sect18" HREF="#toc18"><H2><B>DIAGNOSTICS</B></H2></A>
<I>reject</I>_<I>used</I>_<I>but</I>_<I>not</I>_<I>detected</I>          <I>undefined</I>           or <I>yymore</I>_<I>used</I>_<I>but</I>_<I>not</I>_<I>detected</I> <I>undefined</I> - These errors can occur at compile time. They indicate that the scanner uses <B>REJECT</B> or <B>yymore()</B> but that <I>flex</I> failed to notice the fact, meaning that <I>flex</I> scanned the first two sections looking for occurrences of these actions and failed to find any, but somehow you snuck some in (via a #include file, for example). Make an explicit reference to the action in your <I>flex</I> input file. (Note that previously <I>flex</I> supported a <B>%used/%unused</B> mechanism for dealing with this problem; this feature is still supported but now deprecated, and will go away soon unless the author hears from people who can argue compellingly that they need it.)<P>
<I>flex</I> <I>scanner</I> <I>jammed</I> - a scanner compiled with <B>-s</B> has encountered an input string which wasn't matched by any of its rules.<P>
<I>flex</I> <I>input</I> <I>buffer</I> <I>overflowed</I> - a scanner rule matched a string long enough to overflow the scanner's internal input buffer (16K bytes by default - controlled by <B>YY_BUF_SIZE</B> in &quot;flex.skel". Note that to redefine this macro, you must first <B>#undefine</B> it).<P>
<I>scanner</I> <I>requires</I> -<I>8</I> <I>flag</I> - Your scanner specification includes recognizing 8-bit characters and you did not specify the -8 flag (and your site has not installed flex with -8 as the default).<P>
<I>fatal</I> <I>flex</I> <I>scanner</I> <I>internal</I> <I>error</I>--<I>end</I> <I>of</I> <I>buffer</I> <I>missed</I> This can occur in an scanner which is reentered after a long-jump has jumped out (or over) the scanner's activation frame. Before reentering the scanner, use:<P>
yyrestart( yyin );<P>
<I>too</I> <I>many</I> %<I>t</I> <I>classes</I>! - You managed to put every single character into its own %t class. <I>flex</I> requires that at least one of the classes share characters.<P>

<A NAME="sect19" HREF="#toc19"><H2><B>DEFICIENCIES</B> <B>/</B> <B>BUGS</B></H2></A>
See <A HREF="http://www.stna7.stna.dgac.fr/cgi-bin/man2html?flex?1">flex(1)</A>.<P>

<A NAME="sect20" HREF="#toc20"><H2><B>SEE</B> <B>ALSO</B></H2></A>
<A HREF="http://www.stna7.stna.dgac.fr/cgi-bin/man2html?flex?1">flex(1)</A>, <A HREF="http://www.stna7.stna.dgac.fr/cgi-bin/man2html?lex?1">lex(1)</A>, <A HREF="http://www.stna7.stna.dgac.fr/cgi-bin/man2html?yacc?1">yacc(1)</A>, <A HREF="http://www.stna7.stna.dgac.fr/cgi-bin/man2html?sed?1">sed(1)</A>, <A HREF="http://www.stna7.stna.dgac.fr/cgi-bin/man2html?awk?1">awk(1)</A>.<P>
M. E. Lesk and E. Schmidt, <I>LEX</I> - <I>Lexical</I> <I>Analyzer</I> <I>Generator</I><P>

<A NAME="sect21" HREF="#toc21"><H2><B>AUTHOR</B></H2></A>
Vern Paxson, with the help of many ideas and much inspiration from Van Jacobson. Original version by Jef Poskanzer. The fast table representation is a partial implementation of a design done by Van Jacobson. The implementation was done by Kevin Gong and Vern Paxson.<P>
Thanks to the many <I>flex</I> beta-testers, feedbackers, and contributors, especially Casey Leedom, benson@odi.com, Keith Bostic, Frederic Brehm, Nick Christopher, Jason Coughlin, Scott David Daniels, Leo Eskin, Chris Faylor, Eric Goldman, Eric Hughes, Jeffrey R. Jones, Kevin B. Kenny, Ronald Lamprecht, Greg Lee, Craig Leres, Mohamed el Lozy, Jim Meyering, Marc Nozell, Esmond Pitt, Jef Poskanzer, Jim Roskind, Dave Tallman, Frank Whaley, Ken Yap, and those whose names have slipped my marginal mail-archiving skills but whose contributions are appreciated all the same.<P>
Thanks to Keith Bostic, John Gilmore, Craig Leres, Bob Mulcahy, Rich Salz, and Richard Stallman for help with various distribution headaches.<P>
Thanks to Esmond Pitt and Earle Horton for 8-bit character support; to Benson Margulies and Fred Burke for C++ support; to Ove Ewerlid for the basics of support for NUL's; and to Eric Hughes for the basics of support for multiple buffers.<P>
Work is being done on extending <I>flex</I> to generate scanners in which the state machine is directly represented in C code rather than tables. These scanners may well be substantially faster than those generated using -f or -F. If you are working in this area and are interested in comparing notes and seeing whether redundant work can be avoided, contact Ove Ewerlid (ewerlid@mizar.DoCS.UU.SE).<P>
This work was primarily done when I was at the Real Time Systems Group at the Lawrence Berkeley Laboratory in Berkeley, CA. Many thanks to all there for the support I received.<P>
Send comments to:<P>
Vern Paxson<BR>
 Computer Systems Engineering<BR>
 Bldg. 46A, Room 1123<BR>
 Lawrence Berkeley Laboratory<BR>
 University of California<BR>
 Berkeley, CA 94720<P>
vern@ee.lbl.gov<BR>
 ucbvax!ee.lbl.gov!vern<P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">NAME</A></LI>
<LI><A NAME="toc1" HREF="#sect1">SYNOPSIS</A></LI>
<LI><A NAME="toc2" HREF="#sect2">DESCRIPTION</A></LI>
<LI><A NAME="toc3" HREF="#sect3">SOME SIMPLE EXAMPLES</A></LI>
<LI><A NAME="toc4" HREF="#sect4">FORMAT OF THE INPUT FILE</A></LI>
<LI><A NAME="toc5" HREF="#sect5">PATTERNS</A></LI>
<LI><A NAME="toc6" HREF="#sect6">HOW THE INPUT IS MATCHED</A></LI>
<LI><A NAME="toc7" HREF="#sect7">ACTIONS</A></LI>
<LI><A NAME="toc8" HREF="#sect8">THE GENERATED SCANNER</A></LI>
<LI><A NAME="toc9" HREF="#sect9">START CONDITIONS</A></LI>
<LI><A NAME="toc10" HREF="#sect10">MULTIPLE INPUT BUFFERS</A></LI>
<LI><A NAME="toc11" HREF="#sect11">END-OF-FILE RULES</A></LI>
<LI><A NAME="toc12" HREF="#sect12">MISCELLANEOUS MACROS</A></LI>
<LI><A NAME="toc13" HREF="#sect13">INTERFACING WITH YACC</A></LI>
<LI><A NAME="toc14" HREF="#sect14">TRANSLATION TABLE</A></LI>
<LI><A NAME="toc15" HREF="#sect15">OPTIONS</A></LI>
<LI><A NAME="toc16" HREF="#sect16">PERFORMANCE CONSIDERATIONS</A></LI>
<LI><A NAME="toc17" HREF="#sect17">INCOMPATIBILITIES WITH LEX AND POSIX</A></LI>
<LI><A NAME="toc18" HREF="#sect18">DIAGNOSTICS</A></LI>
<LI><A NAME="toc19" HREF="#sect19">DEFICIENCIES / BUGS</A></LI>
<LI><A NAME="toc20" HREF="#sect20">SEE ALSO</A></LI>
<LI><A NAME="toc21" HREF="#sect21">AUTHOR</A></LI>
</UL>
</BODY></HTML>
