package com.vineel.CoreJavaVolIHorstmann.Generics;

/**
 * Created by vineel on 2/3/16.
 */

/*
    Java's Type Erasure + Compiler black magic! = Bridge methods
 */

// Generic class whose T will be Type Erased by the compiler to Object
class Number<T> {
    protected T number;
    // T gets replaced by Object by compiler before generating class file
    public void setNumber(T number){
        System.out.println("setNumber in Number<T>");
        this.number = number;
    }
    public T getNumber() {
        return number;
    }
}

// Specialized version of Number class which declares setNumber method
class NumberString extends Number<String> {
    //At the first sight it looks like the following method
    //is overriding the super class's setNumber because
    //we extend from Number<String> but unfortunately
    //because of Type Erasure the super class setNumber(T number)
    //becomes setNumber(Object number).
    //This causes setNumber method in sub class to become
    //a method overload instead of method override.
    //KEEP THIS IN MIND WE WILL REVISIT THIS AGAIN IN MAIN METHOD
    public void setNumber(String number) {
        System.out.println("setNumber in NumberString");
        this.number = number;
    }

//    This is generated by compiler
//    public void setNumber(Object number) {
//        //Just call the right method
//        setNumber((String)number);
//    }
}

public class TypeErasureWithSuperAndSubclassExample {
    public static void main(String[] args) {
        // Sub class NumberString is assigned to Super class reference
        Number<String> number = new NumberString();
        // Expecting setNumber to be polymorphically resolved at runtime
        // to the overridden method on NumberString object
        // - Not True without bridge methods
        number.setNumber("10");
        // In the absence of compiler bridge methods.
        // The call setNumber("10") on super class reference will be
        // first overload resolved to just setNumber(Object) since super
        // class reference has no other overload method at compile time.
        // This happens because subclass setNumber is just a overload method
        // not overridden from super class setNumber.
        // So no polymorphic behaviour is observed during runtime.
        // And this overload resolution causes the super class method
        // setNumber(Object) be invoked rather than subclass setNumber(String).
        // Not at all expected by the programmer. Its a clear gotcha
        //
        // To prevent this the compiler synthesizes a special overridden
        // method called setNumber(Object) in subclass, this special
        // method is called bridge method. All this bridge method helps is,
        // It resolves the setNumber call on super class reference to bind
        // to the subclass synthesized setNumber(Object) method,
        // This effectively converts the overloaded call in to overridden
        // call as expected by the programmer and inside the method the
        // compiler generates the code to call the expected subclass
        // setNumber(String).
        //
        // This can be easily validated by running
        //   javap -p NumberString.class
        //        class NumberString extends Number<java.lang.String> {
        //          com.vineel.NumberString();
        //          public void setNumber(java.lang.String);
        //          public void setNumber(java.lang.Object);  //BRIDGE METHOD
        //        }
        //   javap -c NumberString.class
        //        public void setNumber(java.lang.Object);
        //        Code:
        //        0: aload_0
        //        1: aload_1
        //        2: checkcast     #6    // class java/lang/String
        //                               // CALL TO ACTUAL METHOD
        //        5: invokevirtual #7    // Method setNumber:(Ljava/lang/String;)V
        //        8: return

        // Fortunately, Java programmers never have to think about it.
        // The expected behaviour is unchanged with the help of
        // compiler black magic!

        // Bridge methods are not limited to Type Erasure.
        // They are also used when inner classes access private fields of
        // outer classes. That's the topic of another day.

        // Good bye!
    }
}
