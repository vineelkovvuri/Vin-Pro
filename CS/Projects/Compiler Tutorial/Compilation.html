<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Compiler - Compilation | Vineel Kumar Reddy</title>
<link href="CSS/Global.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="syntaxhighlighter/scripts/shCore.js"></script>
<script type="text/javascript" src="syntaxhighlighter/scripts/shBrushCpp.js"></script>
<link rel="stylesheet" type="text/css" href="syntaxhighlighter/styles/shCore.css" />
<link rel="stylesheet" type="text/css" href="syntaxhighlighter/styles/shThemeDefault.css" />
<script type="text/javascript">
SyntaxHighlighter.config.clipboardSwf = 'syntaxhighlighter/scripts/clipboard.swf';
SyntaxHighlighter.all();

</script>


</head>
<body>

<div id="container">
<div id="header">Compilation</div>
<hr class="linebreak"/>

<div id="navigation">
<p>
	<ol>
        <li><a href="Main.html">Main</a></li>
        <li ><a href="Preprocessing.html"> Preprocessing</a></li>
        <li class="selected">Compilation</li>
        <li><a href="Assembling.html">Assembling</a></li>
        <li><a href="Linking.html">Linking</a></li>
        <li><a href="Ethical Cracking.html">Ethical Cracking</a></li>
     </ol>
    </p>
</div>

<div id="content">

<p>
<a href="http://en.wikipedia.org/wiki/Compiler" target="_blank" class="externallink">Compilation</a> is the core phase of a compiler. This phase mainly comprises of following 3 stages
</p>

<p>
<ol>
	<li><a href="http://en.wikipedia.org/wiki/Lexical_analysis" target="_blank" class="externallink">Lexical Analysis</a><br />
   <p> The responsibility of a lexical analyser(or Lexer for short) is to split the given program in to tokens(or lexems) that forms valid programming language constructs.
</p>
    For example consider the following code.
  <pre class="brush: c" name="code" id="code">
 main()
 {
     c = a << b;
 } </pre>
 Now the Lexer recognises the above code as
  <pre class="brush: c" name="code" id="code">
    Identifier(main)  LParen RParen
    LBrace
    Identifier(c) AssignmentOperator Identifier(a) LeftShiftOperator Identifier(b) Semicolon
    RBrace</pre>
    
    In the above output from lexer we can observe that <strong>&lt;&lt;</strong> is recognised as <strong>LeftShiftOperator</strong> not as <strong>LessThan</strong>  followed by a <strong>LessThan</strong>. When ever the lexer encounters these kind of situations it tries to find the largest possible token(lexem).
    <br />
    <br />
    </li>
    <li><a href="http://en.wikipedia.org/wiki/Parsing" target="_blank" class="externallink">Syntax Analysis</a><br />
     <p> The responsibility of a Syntax Analyser is to construct the <a href="http://en.wikipedia.org/wiki/Parse_tree" target="_blank" class="externallink">parse tree</a>  from the above token generated by Lexer. Syntax Analyser tries to find whether the statements present in the input program are valid or not according to the grammer of the language</p>
<p>
    For example consider the following expression
    <pre class="brush: c" name="code" id="code">
    c = a+b*;
    </pre>
     Here the syntax analyser fails to construct the parse tree for the expression because In C language <strong>a+b*</strong> is an invalid expression.
     <br /><br />
    </li>
    <li><a href="http://en.wikipedia.org/wiki/Semantic_analysis_(computer_science)#Front_end" target="_blank" class="externallink">Semantic Analysis</a><br />
    <p>
     Once the  syntax analyser has constructed the parse tree for a program the semantic analyser will try to check the meaning of the program.
    The most important feature of semantic analyser is <strong>Type Checking</strong>
    </p>
     For example consider the following statement. 
       <pre class="brush: c" name="code" id="code">
     floatX2 = floatX1 + 10;
    </pre>
      In the above statement the semantic analyser converts the integer value <em><strong>10</strong></em> to floating point value <em><strong>10.0</strong></em> i.e., it tries to convert the data from one type to other for performing the desired operations.
   <p> ** The conversion between int to float is required in the above statement because the internal representation of int is different from float.</p>
 
    </li>
</ol> 
<hr class="linebreak" style="width:50%;" /><br />
  Once the program passes all these 3 stages the compiler translate the high level program in to its equivalent assembly language program(may not have one-one correspondence due to code optimizations)
   <pre class="brush: c" name="code" id="code">  
 add()
 {
     printf("Add Routine");
 }
 
 main()
 {
     add();
 } 
 </pre>
 now assuming the program is saved as test.c. Issue the following command
 <pre class="brush: c" name="code" id="code">
 gcc -S -masm=intel test.c
 </pre>
  <p><strong>-S</strong> instructs the compiler to stop after the generation of assembly code.</p>
  <p><strong>-masm=intel</strong> By default GCC uses AT&T assembly language syntax but as we are working in windows environment we feel homely if GCC can generated MASM like assembly syntax. Exactly this is what -masm=intel (Machines Assembly) option does.
  </p>
  The above command automatically generates a file named <strong>test.s</strong>
  <div class="image" >
<img src="Pics/2007-07-24_222359.gif" /> <br />
<span class="imagetag">Output from GCC after compilation (<strong>gcc -S -masm=intel test.c</strong>)(test.s opened in Vim )</span>
</div>
<p>
Observe the above code, in line 14 even tough test.s contains no definition for <strong>printf</strong> a call is made to printf  function "how can the compiler produce the final executable for the above program without knowing the definition of printf ?". The answer is simple compilation phase don't have any idea on where the function(printf)  is actually located(glibc). If function prototype exists(here in stdio.h) and there is a mismatch in the prototype of the calling function(printf) then the compiler issues an error <strong>(test.c:5: error: too few arguments to function `printf')</strong>. The scenario where the function don't have a prototype in the source file is dealt in linker phase(will be discussed later). The compiler only know how to convert a given high level language function to a equal assembly language instructions(this is the reason why writing statements out of function is not allowed in majority of programming languages).
</p>
<p>
Similarly whenever your program contains an external variable(like external function printf) the machine code generated for the memory address of that variable is assumed Zeros this is because the compilation phase has no idea on exactly from where these extern variables are coming from.
You can observe this in the following illustration.
</p>
 <pre class="brush: c" name="code" id="code">
main()
{
    //Referring an external variable
    //Don't know where it is coming from
    extern int x;  
    x = 5;
} 
</pre>
  <div class="image" >
<img src="Pics/2007-07-29_140809.png" /> <br />
<span class="imagetag">Disassembly generated by objdump.exe(<strong>objdump -d -m i386:intel test.o</strong>)</span>
</div>
<p>(The above disassembly is generated by a tool named objdump.exe   in GNU compiler collection. It will be discussed latter).</p>
<p>
The linking stuff between the functions and also resolving external references is taken care by the Linker which we will see in later sections.
</p>
<p>
The important consequence of compilation phase is that compilation is not 100% reversible. What I mean by this is, given a piece of assembly language code for a C function one cannot translate it back to its original C code in all the cases. To get the feel of what I mean consider the following code snippet. 
</p>
 <pre class="brush: c" name="code" id="code">
#include&lt;stdio.h&gt;
main()
{
    if(1)  //trivial case
    {
        printf("if");
    }
    else   //Will be discarded by the compilation phase of the compiler 
    {
        printf("else");
    }
} 
</pre>
the code generation for this is done by the compilation phase as 
 <pre class="brush: c" name="code" id="code">
#include&lt;stdio.h&gt;
main()
{
    printf("if");
} 
</pre>

You can even look at the assembly listing of the above code (gcc -S -masm=intel test.c).
  <div class="image" >
<img src="Pics/2007-07-29_013346.png" /> <br />
<span class="imagetag">An illustration showing compiler optimizations</span>
</div>
<p>
So even though I know the above assembly code I may not predict the presence of else block in the source program. This is like asking a person to find the values of x,y in the equation z = x + y given the value of z. The person obviously may not determine the exact pair of values for x,y that resulted in z (the possibilities are infinite).
</p>
<p>
The cause for this is <strong>Compiler Optimizations</strong>. Briefly optimization is the process of eliminating unnecessary instructions(or elements) present in the source program and tweaking the source program instructions such a way that the code generated in the final executable will be efficient. To get a better explanation of compiler optimizations and various factors upon which it depends please refer  <a href="http://en.wikipedia.org/wiki/Compiler_optimization" target="_blank" class="externallink">Compiler Optimizations</a>. Optimization of your code can be broadly based on two factors one is size of the final exe and other is speed  of the generated machine code. This can be controlled using <em><strong>-O</strong></em> flag of GNU C compiler. </p>
</div>

<div id="footer"><hr class="linebreak"/><a href="mailto:vineel.kovvuri[at]gmail.com" class="email">vineel.kovvuri[at]gmail.com</a>
</div>
</div>

</body>
</html>
